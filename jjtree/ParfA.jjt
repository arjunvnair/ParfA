/** * Copyright (c) 2017 Arjun Nair */options{  JDK_VERSION = "1.8";  static = false;  MULTI = true;  NODE_EXTENDS = "ParfANode";  TRACK_TOKENS = true;}PARSER_BEGIN(ParfA)import java.io.File;import java.io.FileInputStream;import java.io.FileOutputStream;import java.io.ByteArrayInputStream;import java.io.FileNotFoundException;import java.io.IOException;import java.io.InputStream;import java.nio.file.Paths;import java.nio.file.Files;import java.nio.charset.StandardCharsets;import java.util.jar.JarOutputStream;import java.util.jar.Manifest;import java.util.jar.Attributes;import java.util.Collection;import java.util.zip.ZipEntry;import javax.swing.ImageIcon;import javax.swing.JFileChooser;import javax.swing.filechooser.FileNameExtensionFilter;import consoleio.C;import org.apache.commons.io.FileUtils;	public class ParfA{    public static void main(String args[]) throws Exception    {       	String answer = "y";      	while(answer.equalsIgnoreCase("y"))      	{			try 			{				Files.createDirectory(Paths.get(System.getProperty("user.home") + "/Documents/ParfA/"));			} 			catch (IOException e) {}			String filename = File.separator + "txt";			JFileChooser fc = new JFileChooser(new File(filename));			fc.setFileFilter(new FileNameExtensionFilter("ParfA Code Files", "txt", "text"));			fc.setCurrentDirectory(new File(System.getProperty("user.home") + "/Documents/ParfA/"));			fc.showOpenDialog(C.io.frame);			openConsole();        	try        	{        		run(new FileInputStream(fc.getSelectedFile().getAbsolutePath()));        	}        	catch(FileNotFoundException e)        	{        	  	C.io.print("File not recognized. Run the program again.");      			C.io.nextLine();      			closeConsole();      			return;      		}      		catch(NullPointerException e)      		{      		  	C.io.print("No file chosen. Run the program again.");      			C.io.nextLine();      			closeConsole();      			return;      		}        	C.io.print("\nProgram finished. Run another program (y/n)? ");        	answer = C.io.nextLine();        	C.io.println();         }         closeConsole();	}	/**	* Compiles and runs a text file with ParfA code	* @param stream the input stream with the code	*/	public static void run(InputStream stream)	{	  	try	  	{	  	  	ParfA parser = new ParfA(stream);        	parser.Program();        	parser.jjtree.rootNode().interpret();      	}        catch (ParseException e)        {        	C.io.println("Syntax error at " + "line:" + e.currentToken.endLine  + ", column:" + e.currentToken.endColumn + ".");            return;        }        catch (TokenMgrError e)        {        	C.io.println("Syntax error.");        	e.printStackTrace();            return;        }        catch(ArrayIndexOutOfBoundsException e)        {          	C.io.println("Program ran out of random access memory and crashed (did you infinite loop?).");          	return;      	}        catch(IllegalStateException e)        {          	return;        }	}	/**	* Compiles and runs a text file with ParfA code	* @param code the code	*/	public static void run(String code)	{		InputStream stream = new ByteArrayInputStream(code.getBytes(StandardCharsets.UTF_8));		ParfA.run(stream);	}	/*	* Exports ParfA code into a binary file	* @param filename the full name of the text file	* @param exportFilename the destination of the binary file	* throws IOException if there is an I/O error		public static void export(String filename, String exportFilename) throws IOException	{	  	Manifest manifest = new Manifest();  		manifest.getMainAttributes().put(Attributes.Name.MANIFEST_VERSION, "1.0");	  	FileOutputStream fout = new FileOutputStream(filename);    	JarOutputStream jout = new JarOutputStream(fout, manifest);		Collection<File> files = FileUtils.listFiles(new File("bin"), null, true);		for(File f : files)		{			jout.putNextEntry(new ZipEntry(f.getName()));			jout.write(Files.readAllBytes(f.toPath()));			jout.closeEntry();		}		jout.close();		fout.close();	}	TODO	*/	/**	* Open console	*/	public static void openConsole()	{		if(C.io.frame == null || !C.io.frame.isVisible())	 	{ 	 		C.io.initComponents();	 		C.io.frame.setTitle("ParfA Compiler");	 		C.io.frame.setIconImage(new ImageIcon("images/ParfA-logo.png").getImage());		}	}	/**	* Close console	*/	public static void closeConsole()	{		if(C.io.frame != null)			C.io.frame.setVisible(false);	}	/**	* Refresh console	*/	public static void refreshConsole()	{	  	closeConsole();	  	openConsole();	}}PARSER_END(ParfA)SKIP :{  " "| "\t"| ";"| "\n"| "\r"}TOKEN: /* DEFINITIONS */{  < #LETTER: ["_","a"-"z","A"-"Z"] >| < #DIGIT: ["0"-"9"] >| < #INTEGER: ["1"-"9"] (["0"-"9"])* | <DIGIT> >| < #CHARACTER : ~["\""] >}TOKEN : /* KEYWORDS */{  < IF : "if" >| < ELSEIF : "else if" >| < ELSE : "else" >| < LOOP : "loop" >| < REPEATUNTIL : "repeatUntil" >| < FOREVER : "forever" >| < WAIT : "wait" >| < WAITUNTIL : "waitUntil" >| < ANNOUNCE : "announce" >| < ASK : "ask" >| < ANSWER : "answer" >| < CREATE : "create" >}TOKEN : /* TYPE KEYWORDS */{  < NUMBER : "number" >| < LOGIC : "logic" >| < TEXT : "text" >| < LIST : "list" >}TOKEN : /* SEPARATORS */{  < LPAR : "(" >| < RPAR : ")" >| < LBRAC : "{" >| < RBRAC : "}" >| < COMMA : "," >}TOKEN : /* OPERATORS */{  < PLUS : "+" >| < MINUS : "-" >| < MULTIPLY : "*" >| < DIVIDE : "/" >| < MODULUS : "%" >| < EQUALS : "equals" | "==">| < NOTEQUAL : "doesnotequal" | "!=" >| < GREATERTHAN: ">"  >| < LESSTHAN: "<"  >| < GREATERTHANOREQUALTO: ">=" >| < LESSTHANOREQUALTO: "<=" >| < AND : "and" | "&" | "&&">| < OR : "or" | "|" | "||">| < NOT : "not" | "!" >| < NUMBEROF : "numberof" | "#" >| < CONTAINS : "contains" >| < LENGTHOF : "lengthof" | "length" >| < ASSIGN : "store" | "=" >| < ADD : "add" >| < REMOVE : "remove" >}TOKEN : /* LITERALS */{  < NUMBER_EXPRESSION : <INTEGER> | <INTEGER> "." <INTEGER> | <INTEGER> "." | "." <INTEGER> >| < TRUE : "true" >| < FALSE : "false" >| < TEXT_EXPRESSION : "\"" (<CHARACTER>)* "\"" >}TOKEN : /* IDENTIFIER */{  < IDENTIFIER: <LETTER> (<LETTER>|<DIGIT>)* >}MORE : /* COMMENTS */{  "/*" : START_LONG_COMMENT}SPECIAL_TOKEN :{  <SINGLE_LINE_COMMENT: "//" (~["\n", "\r"])* ("\n" | "\r" | "\r\n")?>}<START_LONG_COMMENT>SPECIAL_TOKEN :{  <MULTI_LINE_COMMENT: "*/" > : DEFAULT}<START_LONG_COMMENT>MORE :{  < ~[] >}/* Program */void Program(): {}{	(Statement())+	<EOF>}/* Expressions */void Expression() #void: {}{	LogicExpression()	}void LogicExpression() #void: {}{	OrExpression()}void OrExpression() #void: {}{	AndExpression() (LOOKAHEAD(2) <OR> AndExpression() #Or(2))*}void AndExpression() #void: {}{	EqualityExpression() (LOOKAHEAD(2) <AND> EqualityExpression() #And(2))*}void EqualityExpression() #void: {}{	RelationalExpression() [LOOKAHEAD(2) ((<EQUALS> RelationalExpression() #Equals(2)) | (<NOTEQUAL> RelationalExpression() #NotEquals(2)))]}void RelationalExpression() #void: {}{	MathExpression() [(<LESSTHAN> MathExpression() #LessThan(2)) | (<GREATERTHAN> MathExpression() #GreaterThan(2)) | (<LESSTHANOREQUALTO> MathExpression() #LessThanOrEqualTo(2)) | (<GREATERTHANOREQUALTO> MathExpression() #GreaterThanOrEqualTo(2))]}void MathExpression() #void: {}{	AdditiveExpression()}void AdditiveExpression() #void:{}{	MultiplicativeExpression() ((<PLUS> MultiplicativeExpression() #Add(2)) | (<MINUS> MultiplicativeExpression() #Subtract(2)))*}void MultiplicativeExpression() #void: {}{  	NotExpression() ((<MULTIPLY> NotExpression() #Multiply(2)) | (<DIVIDE> NotExpression() #Divide(2)) | (<MODULUS> NotExpression() #Modulus(2)))*}void NotExpression() #void: {}{	Value() | (<NOT> NotExpression() #Not())}void Value() #void: {}{	NumberLiteral() | LogicLiteral() | TextLiteral() | (<LENGTHOF> (TextLiteral() | ListLiteral() | Id()) #Length) | ((ListLiteral() | Id()) [(<CONTAINS> Expression() #Contains(2)) | (<NUMBEROF> Expression() #NumberOf(2))]) | Answer() | (<LPAR> Expression() <RPAR>)}void NumberLiteral():{   Token t;}{ 	t = <NUMBER_EXPRESSION> {jjtThis.val = Double.parseDouble(t.image);}}void LogicLiteral(): {}{	<TRUE> {jjtThis.val = true;} | <FALSE> {jjtThis.val = false;}}void TextLiteral():{	Token t;}{	t = <TEXT_EXPRESSION> {jjtThis.val = new String(t.image.substring(1, t.image.length() - 1));}}void ListLiteral():{}{  	<LBRAC> Expression() (<COMMA> Expression())* <RBRAC>}void Id():{	Token t;}{	t = <IDENTIFIER> {jjtThis.name = t.image;}}void Answer(): {}{	<ANSWER>}/* STATEMENTS */void IfStatement():{  	jjtThis.elseIfCount = 0;}{  	<IF> <LPAR> LogicExpression() <RPAR>    Block()	(<ELSEIF> <LPAR> LogicExpression() <RPAR>    Block() {jjtThis.elseIfCount++;})*	[<ELSE>    Block()] }void LoopStatement():{}{    <LOOP> <LPAR> MathExpression() <RPAR>    Block()}void RepeatUntilStatement(): {}{	<REPEATUNTIL> <LPAR> LogicExpression() <RPAR>	Block()}void ForeverStatement():{}{    <FOREVER>    Block()}void WaitStatement():{}{	<WAIT> MathExpression()}void WaitUntilStatement():{}{               	<WAIT> LogicExpression()}void AnnounceStatement(): {}{	<ANNOUNCE> Expression()}void AskStatement(): {}{	<ASK> Expression()}void ListAddStatement(): {}{  	Id() <ADD> Expression() (<COMMA> Expression())*}void ListRemoveStatement(): {}{	Id() <REMOVE> Expression() (<COMMA> Expression())*}void VariableDeclareStatement():{	Token t;}{	<CREATE> (<NUMBER> {jjtThis.type = ParfAConstants.NUMBER;} | <LOGIC> {jjtThis.type = ParfAConstants.LOGIC;} | <TEXT> {jjtThis.type = ParfAConstants.TEXT;} | <LIST> {jjtThis.type = ParfAConstants.LIST;}) t = <IDENTIFIER>  {jjtThis.name = t.image;} }void VariableAssignStatement(): {}{	 Id() <ASSIGN> Expression()}void VariableDeclareAssignStatement():{  	Token t;}{	 <CREATE> (<NUMBER> {jjtThis.type = ParfAConstants.NUMBER;} | <LOGIC> {jjtThis.type = ParfAConstants.LOGIC;} | <TEXT> {jjtThis.type = ParfAConstants.TEXT;} | <LIST> {jjtThis.type = ParfAConstants.LIST;})  t = <IDENTIFIER>  {jjtThis.name = t.image;} <ASSIGN> Expression()} void Block(): {}{	<LBRAC>    	(Statement())*    <RBRAC>}void Statement() #void: {}{  LOOKAHEAD(VariableDeclareAssignStatement()) VariableDeclareAssignStatement()| LOOKAHEAD(2) VariableAssignStatement()| LOOKAHEAD(3) VariableDeclareStatement()| LOOKAHEAD(2) ListAddStatement()| ListRemoveStatement()| IfStatement()| LoopStatement()| RepeatUntilStatement()| ForeverStatement()| LOOKAHEAD(3) WaitStatement()| WaitUntilStatement()| LOOKAHEAD(2) AnnounceStatement()| AskStatement()}