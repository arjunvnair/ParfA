options{  JDK_VERSION = "1.8";  static = true;  MULTI = true;  NODE_EXTENDS = "ParfANode";  TRACK_TOKENS = true;}PARSER_BEGIN(ParfA)import java.util.Scanner;import java.io.File;import java.io.FileInputStream;import java.io.FileOutputStream;import java.io.FileNotFoundException;import java.io.IOException;import java.nio.file.Files;import java.util.jar.JarOutputStream;import java.util.jar.Manifest;import java.util.jar.Attributes;import java.util.Collection;import java.util.zip.ZipEntry;import org.apache.commons.io.FileUtils;	public class ParfA{    public static void main(String args[]) throws Exception    {      	Scanner s = new Scanner(System.in);      	System.out.print("Enter the file path to your ParfA code: ");      	String filename = s.nextLine();      	while(!(new File(filename)).exists())      	{      	  	System.out.print("File not recognized, double check your file path and enter again: ");      		filename = s.nextLine();     	}        try        {        	run(filename);        }        catch (TokenMgrError e)        {        	e.printStackTrace();            return;        }	}	/**	* Compiles and runs a text file with ParfA code	* @param filename the full name of the text file	* @throws FileNotFoundException if the file cannot be located	*/	public static void run(String filename) throws FileNotFoundException	{	  	try	  	{	  	  	ParfA parser = new ParfA(new FileInputStream(filename));        	parser.Program();        	parser.jjtree.rootNode().interpret();      	}        catch (ParseException e)        {        	System.err.println("Syntax error at " + "line:" + e.currentToken.endLine  + ", column:" + e.currentToken.endColumn + ".");            return;        }        catch (TokenMgrError e)        {        	System.err.println("Syntax error.");            return;        }        catch(ArrayIndexOutOfBoundsException e)        {          	System.err.println("Program ran out of random access memory and crashed (did you infinite loop?).");          	return;      	}        catch(IllegalStateException e)        {          	return;        }	}	/*	* Exports ParfA code into a binary file	* @param filename the full name of the text file	* @param exportFilename the destination of the binary file	* throws IOException if there is an I/O error		public static void export(String filename, String exportFilename) throws IOException	{	  	Manifest manifest = new Manifest();  		manifest.getMainAttributes().put(Attributes.Name.MANIFEST_VERSION, "1.0");	  	FileOutputStream fout = new FileOutputStream(filename);    	JarOutputStream jout = new JarOutputStream(fout, manifest);		Collection<File> files = FileUtils.listFiles(new File("bin"), null, true);		for(File f : files)		{			jout.putNextEntry(new ZipEntry(f.getName()));			jout.write(Files.readAllBytes(f.toPath()));			jout.closeEntry();		}		jout.close();		fout.close();	}	TODO	*/}PARSER_END(ParfA)SKIP :{  " "| "\t"| ";"| "\n"| "\r"}TOKEN: /* DEFINITIONS */{  < #LETTER: ["_","a"-"z","A"-"Z"] >| < #DIGIT: ["0"-"9"] >| < #INTEGER: ["1"-"9"] (["0"-"9"])* | <DIGIT> >| < #CHARACTER : ~["\""] >}TOKEN : /* KEYWORDS */{  < IF : "if" >| < ELSEIF : "else if" >| < ELSE : "else" >| < LOOP : "loop" >| < REPEATUNTIL : "repeatUntil" >| < FOREVER : "forever" >| < WAIT : "wait" >| < WAITUNTIL : "waitUntil" >| < ANNOUNCE : "announce" >| < ASK : "ask" >| < ANSWER : "answer" >| < CREATE : "create" >}TOKEN : /* TYPE KEYWORDS */{  < NUMBER : "number" >| < LOGIC : "logic" >| < TEXT : "text" >| < LIST : "list" >}TOKEN : /* SEPARATORS */{  < LPAR : "(" >| < RPAR : ")" >| < LBRAC : "{" >| < RBRAC : "}" >| < COMMA : "," >}TOKEN : /* OPERATORS */{  < PLUS : "+" >| < MINUS : "-" >| < MULTIPLY : "*" >| < DIVIDE : "/" >| < MODULUS : "%" >| < EQUALS : "equals" | "==">| < NOTEQUAL : "doesnotequal" | "!=" >| < GREATERTHAN: ">"  >| < LESSTHAN: "<"  >| < GREATERTHANOREQUALTO: ">=" >| < LESSTHANOREQUALTO: "<=" >| < AND : "and" | "&" | "&&">| < OR : "or" | "|" | "||">| < NOT : "not" | "!" >| < NUMBEROF : "numberof" | "#" >| < CONTAINS : "contains" >| < LENGTHOF : "lengthof" | "length" >| < ASSIGN : "store" | "=" >| < ADD : "add" >| < REMOVE : "remove" >}TOKEN : /* LITERALS */{  < NUMBER_EXPRESSION : <INTEGER> | <INTEGER> "." <INTEGER> | <INTEGER> "." | "." <INTEGER> >| < TRUE : "true" >| < FALSE : "false" >| < TEXT_EXPRESSION : "\"" (<CHARACTER>)* "\"" >}TOKEN : /* IDENTIFIER */{  < IDENTIFIER: <LETTER> (<LETTER>|<DIGIT>)* >}MORE : /* COMMENTS */{  "/*" : START_LONG_COMMENT}SPECIAL_TOKEN :{  <SINGLE_LINE_COMMENT: "//" (~["\n", "\r"])* ("\n" | "\r" | "\r\n")?>}<START_LONG_COMMENT>SPECIAL_TOKEN :{  <MULTI_LINE_COMMENT: "*/" > : DEFAULT}<START_LONG_COMMENT>MORE :{  < ~[] >}/* Program */void Program(): {}{	(Statement())+	<EOF>}/* Expressions */void Expression() #void: {}{	LogicExpression()	}void LogicExpression() #void: {}{	OrExpression()}void OrExpression() #void: {}{	AndExpression() (LOOKAHEAD(2) <OR> AndExpression() #Or(2))*}void AndExpression() #void: {}{	EqualityExpression() (LOOKAHEAD(2) <AND> EqualityExpression() #And(2))*}void EqualityExpression() #void: {}{	RelationalExpression() [LOOKAHEAD(2) ((<EQUALS> RelationalExpression() #Equals(2)) | (<NOTEQUAL> RelationalExpression() #NotEquals(2)))]}void RelationalExpression() #void: {}{	MathExpression() [(<LESSTHAN> MathExpression() #LessThan(2)) | (<GREATERTHAN> MathExpression() #GreaterThan(2)) | (<LESSTHANOREQUALTO> MathExpression() #LessThanOrEqualTo(2)) | (<GREATERTHANOREQUALTO> MathExpression() #GreaterThanOrEqualTo(2))]}void MathExpression() #void: {}{	AdditiveExpression()}void AdditiveExpression() #void:{}{	MultiplicativeExpression() ((<PLUS> MultiplicativeExpression() #Add(2)) | (<MINUS> MultiplicativeExpression() #Subtract(2)))*}void MultiplicativeExpression() #void: {}{  	NotExpression() ((<MULTIPLY> NotExpression() #Multiply(2)) | (<DIVIDE> NotExpression() #Divide(2)) | (<MODULUS> NotExpression() #Modulus(2)))*}void NotExpression() #void: {}{	Value() | (<NOT> NotExpression() #Not(2))}void Value() #void: {}{	NumberLiteral() | LogicLiteral() | TextLiteral() | (<LENGTHOF> (TextLiteral() | ListLiteral() | Id()) #Length) | ((ListLiteral() | Id()) [(<CONTAINS> Expression() #Contains(2)) | (<NUMBEROF> Expression() #NumberOf(2))]) | Answer() | (<LPAR> Expression() <RPAR>)}void NumberLiteral():{   Token t;}{ 	t = <NUMBER_EXPRESSION> {jjtThis.val = Double.parseDouble(t.image);}}void LogicLiteral(): {}{	<TRUE> {jjtThis.val = true;} | <FALSE> {jjtThis.val = false;}}void TextLiteral():{	Token t;}{	t = <TEXT_EXPRESSION> {jjtThis.val = new String(t.image.substring(1, t.image.length() - 1));}}void ListLiteral():{}{  	<LBRAC> Expression() (<COMMA> Expression())* <RBRAC>}void Id():{	Token t;}{	t = <IDENTIFIER> {jjtThis.name = t.image;}}void Answer(): {}{	<ANSWER>}/* STATEMENTS */void IfStatement():{  	jjtThis.elseIfCount = 0;}{  	<IF> <LPAR> LogicExpression() <RPAR>    Block()	(<ELSEIF> <LPAR> LogicExpression() <RPAR>    Block() {jjtThis.elseIfCount++;})*	[<ELSE>    Block()] }void LoopStatement():{}{    <LOOP> <LPAR> MathExpression() <RPAR>    Block()}void RepeatUntilStatement(): {}{	<REPEATUNTIL> <LPAR> LogicExpression() <RPAR>	Block()}void ForeverStatement():{}{    <FOREVER>    Block()}void WaitStatement():{}{	<WAIT> <LPAR> MathExpression() <RPAR>}void WaitUntilStatement():{}{               	<WAIT> <LPAR> LogicExpression() <RPAR>}void AnnounceStatement(): {}{	<ANNOUNCE> Expression()}void AskStatement(): {}{	<ASK> Expression()}void ListAddStatement(): {}{  	Id() <ADD> Expression() (<COMMA> Expression())*}void ListRemoveStatement(): {}{	Id() <REMOVE> Expression() (<COMMA> Expression())*}void VariableDeclareStatement():{	Token t;}{	<CREATE> (<NUMBER> {jjtThis.type = ParfAConstants.NUMBER;} | <LOGIC> {jjtThis.type = ParfAConstants.LOGIC;} | <TEXT> {jjtThis.type = ParfAConstants.TEXT;} | <LIST> {jjtThis.type = ParfAConstants.LIST;}) t = <IDENTIFIER>  {jjtThis.name = t.image;} }void VariableAssignStatement(): {}{	 Id() <ASSIGN> Expression()}void VariableDeclareAssignStatement():{  	Token t;}{	 <CREATE> (<NUMBER> {jjtThis.type = ParfAConstants.NUMBER;} | <LOGIC> {jjtThis.type = ParfAConstants.LOGIC;} | <TEXT> {jjtThis.type = ParfAConstants.TEXT;} | <LIST> {jjtThis.type = ParfAConstants.LIST;})  t = <IDENTIFIER>  {jjtThis.name = t.image;} <ASSIGN> Expression()} void Block(): {}{	<LBRAC>    	(Statement())*    <RBRAC>}void Statement() #void: {}{  LOOKAHEAD(VariableDeclareAssignStatement()) VariableDeclareAssignStatement()| LOOKAHEAD(2) VariableAssignStatement()| LOOKAHEAD(3) VariableDeclareStatement()| LOOKAHEAD(2) ListAddStatement()| ListRemoveStatement()| IfStatement()| LoopStatement()| RepeatUntilStatement()| ForeverStatement()| LOOKAHEAD(3) WaitStatement()| WaitUntilStatement()| LOOKAHEAD(2) AnnounceStatement()| AskStatement()}